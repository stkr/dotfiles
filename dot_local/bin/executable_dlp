#!/usr/bin/env python

import argparse
import datetime
import json
import logging
import pathlib
import pprint
import queue
import re
import socket
import subprocess
import sys
import threading
import time
import os

YT_DLP_PATH = 'yt-dlp'
MPV_PATH = 'mpv'

HOME_PATH = pathlib.Path(os.environ['HOME'])
VIDEO_DIR_PATH = HOME_PATH / '.tmp/video'
VIDEO_DIR_PATH_SHARED = HOME_PATH / 'remote/player/Videos'
LOG_FILE_PATH = VIDEO_DIR_PATH / 'download_and_play.log'
MPV_IPC_SOCKET_PATH = pathlib.Path('/tmp/mpvsocket')

NEWLINE = "\n".encode("utf-8")

logger = logging.getLogger(__name__)


def setup_logging():
    pathlib.Path(LOG_FILE_PATH).parent.mkdir(parents=True, exist_ok=True)
    logger.setLevel(logging.INFO)

    ch = logging.StreamHandler(sys.stderr)
    ch_format = logging.Formatter("%(message)s")
    ch.setFormatter(ch_format)
    ch.setLevel(logging.INFO)
    logger.addHandler(ch)

    fh = logging.FileHandler(LOG_FILE_PATH)
    fh_format = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
    fh.setFormatter(fh_format)
    fh.setLevel(logging.WARNING)
    logger.addHandler(fh)


def get_video_path(video_dir, filename):
    return [f for f in video_dir.glob(filename + "*") if not f.name.endswith("info.json")][0]


def sane_filename(filename):
    return re.sub(r'[^\s\w\d-]', '_', filename)


def download(url, video_dir_path):
    now = datetime.datetime.now()
    filename = str(now.strftime("%Y-%m-%d-%H-%M-%S-%f"))
    subprocess.run([YT_DLP_PATH, '-P', video_dir_path, '-o', filename, '--write-info-json', url], check=True)

    info_path = video_dir_path.joinpath(filename + ".info.json")
    video_path = get_video_path(video_dir_path, filename)
    with open(info_path, "r") as fp:
        video_info = json.load(fp)
    new_filename = (now.strftime("%Y-%m-%d-%H-%M-%S") +
                    " - " + sane_filename(video_info['id']) +
                    " - " + sane_filename(video_info['title']) +
                    video_path.suffix)
    new_path = video_dir_path.joinpath(new_filename)
    info_path.unlink()
    video_path.rename(new_path)
    return new_path


class MpvIpc:
    def __init__(self):
        self.process = None
        self.rx_queue = queue.SimpleQueue()
        self.tx_queue = queue.SimpleQueue()

        self.terminated = False
        self.recv_thread = None

    @staticmethod
    def _is_mpv_server_socket_alive():
        if MPV_IPC_SOCKET_PATH.is_socket():
            try:
                with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:
                    sock.connect(str(MPV_IPC_SOCKET_PATH))
                    return True
            except ConnectionRefusedError:
                pass
        return False

    def start(self):
        if self._is_mpv_server_socket_alive():
            self._start_recv_thread()
            return

        start = datetime.datetime.now()
        timeout = start + datetime.timedelta(seconds=5)
        self.process = subprocess.Popen([MPV_PATH, f'--input-ipc-server={str(MPV_IPC_SOCKET_PATH)}', '--idle'])
        while datetime.datetime.now() < timeout:
            if self._is_mpv_server_socket_alive():
                self._start_recv_thread()
                return
            time.sleep(0.01)
        raise ValueError("Unable to spawn and connect to mpv.")

    def _start_recv_thread(self):
        self.recv_thread = threading.Thread(None, self._recv_thread_func, "recv_thread")
        self.recv_thread.start()

    def _try_recv(self, sock, rx_buf):
        try:
            return rx_buf + sock.recv(1024)
        except TimeoutError:
            return rx_buf

    def _try_get_tx(self):
        try:
            return self.tx_queue.get(block=False)
        except queue.Empty:
            return None

    def _recv_thread_func(self):
        with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as sock:
            sock.connect(str(MPV_IPC_SOCKET_PATH))
            sock.settimeout(1)
            rx_buf = b""
            while not self.terminated:
                rx_buf = self._try_recv(sock, rx_buf)
                lines = rx_buf.split(NEWLINE)
                rx_buf = lines.pop()
                for line in lines:
                    obj = json.loads(line.decode("utf-8"))
                    if not "event" in obj:
                        self.rx_queue.put(obj)
                tx = self._try_get_tx()
                if tx is not None:
                    tx_buf = (json.dumps(tx) + "\n").encode("utf-8")
                    sock.sendall(tx_buf)

    def communicate(self, tx):
        self.tx_queue.put(tx)
        print(f"tx: {pprint.pformat(tx)}")
        rx = self.rx_queue.get()
        print(f"rx: {pprint.pformat(rx)}")
        return rx

    def wait(self):
        if self.process is not None:
            self.process.wait()
        self.terminated = True
        self.recv_thread.join()


def enqueue(ipc, video_path):
    return ipc.communicate({"command": ["loadfile", str(video_path), "append"]})


def play(ipc, video_path):
    return ipc.communicate({"command": ["loadfile", str(video_path), "append-play"]})


def main():
    setup_logging()
    parser = argparse.ArgumentParser()
    parser.add_argument("url")
    parser.add_argument("--play", default=True, action=argparse.BooleanOptionalAction)
    parser.add_argument("--shared", default=False, action=argparse.BooleanOptionalAction)
    args = parser.parse_args()
    ipc = MpvIpc()
    try:
        video_dir_path = VIDEO_DIR_PATH_SHARED if args.shared else VIDEO_DIR_PATH
        video_path = download(args.url, video_dir_path)
        logger.info(f"Successfully downloaded [{video_path}]")
        ipc.start()
        if args.play:
            play(ipc, video_path)
        else:
            enqueue(ipc, video_path)
    except Exception as ex:
        logger.fatal(ex)
        raise (ex)
    finally:
        ipc.wait()


if __name__ == "__main__":
    main()
